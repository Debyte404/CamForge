#!/usr/bin/env python3
"""
PyForge - Python to C++ Transpiler for ESP32
============================================

Converts Python scripts to native C++ code for ESP32 compilation.
Zero runtime overhead - all Python is converted at compile time.

Usage:
    python pyforge.py --input mods/my_filter.py --output src/mods/my_filter.cpp
"""

import ast
import sys
import os
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Set

# Type mapping: Python -> C++
TYPE_MAP = {
    'int': 'int32_t',
    'float': 'float',
    'bool': 'bool',
    'str': 'String',
    'list': 'std::vector',
    'dict': 'std::map',
    'Frame': 'CamFrame&',
    'Filter': 'ImageFilter',
    'None': 'void',
}

class PyForgeCompiler(ast.NodeVisitor):
    """AST visitor that generates C++ code from Python"""
    
    def __init__(self):
        self.output: List[str] = []
        self.indent_level = 0
        self.imports: Set[str] = set()
        self.class_name: Optional[str] = None
        self.in_class = False
        self.local_vars: Dict[str, str] = {}
        
    def indent(self) -> str:
        return "    " * self.indent_level
    
    def emit(self, code: str):
        self.output.append(self.indent() + code)
    
    def emit_raw(self, code: str):
        self.output.append(code)
    
    def get_type(self, annotation) -> str:
        """Convert Python type annotation to C++ type"""
        if annotation is None:
            return "auto"
        if isinstance(annotation, ast.Name):
            return TYPE_MAP.get(annotation.id, annotation.id)
        if isinstance(annotation, ast.Constant):
            return TYPE_MAP.get(str(annotation.value), str(annotation.value))
        if isinstance(annotation, ast.Subscript):
            # Handle List[int], Dict[str, int], etc.
            base = self.get_type(annotation.value)
            if isinstance(annotation.slice, ast.Tuple):
                args = ", ".join(self.get_type(e) for e in annotation.slice.elts)
            else:
                args = self.get_type(annotation.slice)
            return f"{base}<{args}>"
        return "auto"
    
    def visit_Module(self, node: ast.Module) -> str:
        # Header
        self.emit_raw("// Generated by PyForge - DO NOT EDIT")
        self.emit_raw("// Source: Python transpiled to C++")
        self.emit_raw("")
        self.emit_raw('#include "pyforge_runtime.hpp"')
        self.emit_raw('#include "../core/Camera.hpp"')
        self.emit_raw('#include "../filters/FilterChain.hpp"')
        self.emit_raw("")
        
        # Visit all nodes
        for child in node.body:
            self.visit(child)
        
        return "\n".join(self.output)
    
    def visit_Import(self, node: ast.Import):
        for alias in node.names:
            self.imports.add(alias.name)
    
    def visit_ImportFrom(self, node: ast.ImportFrom):
        self.imports.add(node.module or "")
    
    def visit_ClassDef(self, node: ast.ClassDef):
        self.class_name = node.name
        self.in_class = True
        
        # Get base classes
        bases = []
        for base in node.bases:
            if isinstance(base, ast.Name):
                if base.id == "Filter":
                    bases.append("public ImageFilter")
                else:
                    bases.append(f"public {base.id}")
        
        base_str = " : " + ", ".join(bases) if bases else ""
        
        self.emit_raw(f"class {node.name}{base_str} {{")
        self.emit_raw("public:")
        self.indent_level += 1
        
        # Constructor
        self.emit(f'{node.name}() : ImageFilter("{node.name}") {{}}')
        self.emit_raw("")
        
        # Methods
        for item in node.body:
            if isinstance(item, ast.FunctionDef):
                self.visit_FunctionDef(item, is_method=True)
        
        self.indent_level -= 1
        self.emit_raw("};")
        self.emit_raw("")
        
        # Create global instance
        self.emit_raw(f"// Global instance")
        self.emit_raw(f"{node.name} {node.name.lower()}_instance;")
        self.emit_raw("")
        
        self.in_class = False
        self.class_name = None
    
    def visit_FunctionDef(self, node: ast.FunctionDef, is_method: bool = False):
        # Return type
        return_type = self.get_type(node.returns)
        
        # Parameters
        params = []
        for arg in node.args.args:
            if arg.arg == "self":
                continue
            param_type = self.get_type(arg.annotation)
            params.append(f"{param_type} {arg.arg}")
        
        param_str = ", ".join(params)
        
        # Special handling for 'process' method in filters
        override = " override" if is_method and node.name == "process" else ""
        
        self.emit(f"{return_type} {node.name}({param_str}){override} {{")
        self.indent_level += 1
        
        # Function body
        for stmt in node.body:
            self.visit(stmt)
        
        self.indent_level -= 1
        self.emit("}")
        self.emit_raw("")
    
    def visit_For(self, node: ast.For):
        # Handle range() loops
        if isinstance(node.iter, ast.Call) and isinstance(node.iter.func, ast.Name):
            if node.iter.func.id == "range":
                args = node.iter.args
                target = node.target.id if isinstance(node.target, ast.Name) else "i"
                
                if len(args) == 1:
                    self.emit(f"for (int {target} = 0; {target} < {self.visit_expr(args[0])}; {target}++) {{")
                elif len(args) == 2:
                    self.emit(f"for (int {target} = {self.visit_expr(args[0])}; {target} < {self.visit_expr(args[1])}; {target}++) {{")
                elif len(args) == 3:
                    self.emit(f"for (int {target} = {self.visit_expr(args[0])}; {target} < {self.visit_expr(args[1])}; {target} += {self.visit_expr(args[2])}) {{")
                
                self.indent_level += 1
                for stmt in node.body:
                    self.visit(stmt)
                self.indent_level -= 1
                self.emit("}")
                return
        
        # General for loop (for item in container)
        target = node.target.id if isinstance(node.target, ast.Name) else "_item"
        container = self.visit_expr(node.iter)
        self.emit(f"for (auto& {target} : {container}) {{")
        self.indent_level += 1
        for stmt in node.body:
            self.visit(stmt)
        self.indent_level -= 1
        self.emit("}")
    
    def visit_If(self, node: ast.If):
        cond = self.visit_expr(node.test)
        self.emit(f"if ({cond}) {{")
        self.indent_level += 1
        for stmt in node.body:
            self.visit(stmt)
        self.indent_level -= 1
        
        if node.orelse:
            if len(node.orelse) == 1 and isinstance(node.orelse[0], ast.If):
                self.emit("} else ")
                self.visit(node.orelse[0])
            else:
                self.emit("} else {")
                self.indent_level += 1
                for stmt in node.orelse:
                    self.visit(stmt)
                self.indent_level -= 1
                self.emit("}")
        else:
            self.emit("}")
    
    def visit_While(self, node: ast.While):
        cond = self.visit_expr(node.test)
        self.emit(f"while ({cond}) {{")
        self.indent_level += 1
        for stmt in node.body:
            self.visit(stmt)
        self.indent_level -= 1
        self.emit("}")
    
    def visit_Return(self, node: ast.Return):
        if node.value:
            self.emit(f"return {self.visit_expr(node.value)};")
        else:
            self.emit("return;")
    
    def visit_Assign(self, node: ast.Assign):
        target = self.visit_expr(node.targets[0])
        value = self.visit_expr(node.value)
        
        # Check if this is a new variable
        if isinstance(node.targets[0], ast.Name):
            var_name = node.targets[0].id
            if var_name not in self.local_vars:
                self.local_vars[var_name] = "auto"
                self.emit(f"auto {target} = {value};")
                return
        
        self.emit(f"{target} = {value};")
    
    def visit_AnnAssign(self, node: ast.AnnAssign):
        var_type = self.get_type(node.annotation)
        target = self.visit_expr(node.target)
        
        if node.value:
            value = self.visit_expr(node.value)
            self.emit(f"{var_type} {target} = {value};")
        else:
            self.emit(f"{var_type} {target};")
    
    def visit_Expr(self, node: ast.Expr):
        expr = self.visit_expr(node.value)
        if expr:
            self.emit(f"{expr};")
    
    def visit_expr(self, node) -> str:
        """Visit an expression and return C++ code as string"""
        if isinstance(node, ast.Name):
            return node.id
        
        if isinstance(node, ast.Constant):
            if isinstance(node.value, str):
                return f'"{node.value}"'
            if isinstance(node.value, bool):
                return "true" if node.value else "false"
            return str(node.value)
        
        if isinstance(node, ast.BinOp):
            left = self.visit_expr(node.left)
            right = self.visit_expr(node.right)
            op = self.binop_to_str(node.op)
            return f"({left} {op} {right})"
        
        if isinstance(node, ast.Compare):
            left = self.visit_expr(node.left)
            comparisons = []
            for op, comp in zip(node.ops, node.comparators):
                comparisons.append(f"{self.cmpop_to_str(op)} {self.visit_expr(comp)}")
            return f"({left} {' '.join(comparisons)})"
        
        if isinstance(node, ast.BoolOp):
            op = " && " if isinstance(node.op, ast.And) else " || "
            values = [self.visit_expr(v) for v in node.values]
            return f"({op.join(values)})"
        
        if isinstance(node, ast.UnaryOp):
            operand = self.visit_expr(node.operand)
            if isinstance(node.op, ast.Not):
                return f"!{operand}"
            if isinstance(node.op, ast.USub):
                return f"-{operand}"
            return operand
        
        if isinstance(node, ast.Call):
            func = self.visit_expr(node.func)
            args = ", ".join(self.visit_expr(a) for a in node.args)
            return f"{func}({args})"
        
        if isinstance(node, ast.Attribute):
            value = self.visit_expr(node.value)
            return f"{value}.{node.attr}"
        
        if isinstance(node, ast.Subscript):
            value = self.visit_expr(node.value)
            slice_val = self.visit_expr(node.slice)
            return f"{value}[{slice_val}]"
        
        if isinstance(node, ast.Tuple):
            elements = ", ".join(self.visit_expr(e) for e in node.elts)
            return f"std::make_tuple({elements})"
        
        if isinstance(node, ast.List):
            elements = ", ".join(self.visit_expr(e) for e in node.elts)
            return f"{{{elements}}}"
        
        return ""
    
    def binop_to_str(self, op) -> str:
        ops = {
            ast.Add: "+", ast.Sub: "-", ast.Mult: "*", ast.Div: "/",
            ast.Mod: "%", ast.Pow: "**", ast.LShift: "<<", ast.RShift: ">>",
            ast.BitOr: "|", ast.BitXor: "^", ast.BitAnd: "&", ast.FloorDiv: "/"
        }
        return ops.get(type(op), "+")
    
    def cmpop_to_str(self, op) -> str:
        ops = {
            ast.Eq: "==", ast.NotEq: "!=", ast.Lt: "<", ast.LtE: "<=",
            ast.Gt: ">", ast.GtE: ">=", ast.Is: "==", ast.IsNot: "!="
        }
        return ops.get(type(op), "==")


def compile_file(input_path: str, output_path: str) -> bool:
    """Compile a Python file to C++"""
    try:
        with open(input_path, 'r') as f:
            source = f.read()
        
        tree = ast.parse(source)
        compiler = PyForgeCompiler()
        cpp_code = compiler.visit_Module(tree)
        
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(cpp_code)
        
        print(f"[PyForge] Compiled: {input_path} -> {output_path}")
        return True
        
    except SyntaxError as e:
        print(f"[PyForge] Syntax error in {input_path}: {e}")
        return False
    except Exception as e:
        print(f"[PyForge] Error compiling {input_path}: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(description="PyForge - Python to C++ Transpiler")
    parser.add_argument("--input", "-i", required=True, help="Input Python file")
    parser.add_argument("--output", "-o", required=True, help="Output C++ file")
    args = parser.parse_args()
    
    success = compile_file(args.input, args.output)
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()

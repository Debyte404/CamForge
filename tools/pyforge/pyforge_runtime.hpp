#pragma once
/**
 * @file pyforge_runtime.hpp
 * @brief Runtime Support Library for PyForge Transpiled Code
 * 
 * Provides Python-like constructs (lists, dicts, string helpers)
 * for C++ code generated by PyForge.
 * 
 * MEMORY ARCHITECTURE:
 * - Core camera logic: 400KB Internal SRAM
 * - PyForge mods: Allocated from 8MB PSRAM
 * 
 * Use ps_malloc() for large allocations in mods.
 */

#include <Arduino.h>

// ============================================================
// PSRAM Allocation Helpers for Mods
// ============================================================
#ifdef BOARD_HAS_PSRAM
    #define MOD_MALLOC(size) ps_malloc(size)
    #define MOD_CALLOC(n, size) ps_calloc(n, size)
    #define MOD_REALLOC(ptr, size) ps_realloc(ptr, size)
#else
    #define MOD_MALLOC(size) malloc(size)
    #define MOD_CALLOC(n, size) calloc(n, size)
    #define MOD_REALLOC(ptr, size) realloc(ptr, size)
#endif
#define MOD_FREE(ptr) free(ptr)

// Maximum elements for fixed containers (to avoid dynamic allocation in core)
#define MAX_LIST_SIZE 256
#define MAX_DICT_SIZE 64

namespace pyforge {

// ============================================================
// Python-like Range Iterator
// ============================================================
class range {
public:
    class iterator {
        int value, step;
    public:
        iterator(int v, int s) : value(v), step(s) {}
        int operator*() const { return value; }
        iterator& operator++() { value += step; return *this; }
        bool operator!=(const iterator& other) const { return value < other.value; }
    };
    
    range(int end) : start_(0), end_(end), step_(1) {}
    range(int start, int end) : start_(start), end_(end), step_(1) {}
    range(int start, int end, int step) : start_(start), end_(end), step_(step) {}
    
    iterator begin() const { return iterator(start_, step_); }
    iterator end() const { return iterator(end_, step_); }
    
private:
    int start_, end_, step_;
};

// ============================================================
// Python-like List
// ============================================================
template<typename T>
class List : public std::vector<T> {
public:
    using std::vector<T>::vector;
    
    void append(const T& item) { this->push_back(item); }
    
    T pop() {
        T item = this->back();
        this->pop_back();
        return item;
    }
    
    void insert(int index, const T& item) {
        std::vector<T>::insert(this->begin() + index, item);
    }
    
    void remove(const T& item) {
        auto it = std::find(this->begin(), this->end(), item);
        if (it != this->end()) this->erase(it);
    }
    
    int index(const T& item) const {
        auto it = std::find(this->begin(), this->end(), item);
        return (it != this->end()) ? std::distance(this->begin(), it) : -1;
    }
    
    int count(const T& item) const {
        return std::count(this->begin(), this->end(), item);
    }
    
    void reverse() {
        std::reverse(this->begin(), this->end());
    }
    
    int len() const { return this->size(); }
};

// ============================================================
// Python-like Dict
// ============================================================
template<typename K, typename V>
class Dict : public std::map<K, V> {
public:
    using std::map<K, V>::map;
    
    bool has_key(const K& key) const {
        return this->find(key) != this->end();
    }
    
    V get(const K& key, const V& default_val = V()) const {
        auto it = this->find(key);
        return (it != this->end()) ? it->second : default_val;
    }
    
    List<K> keys() const {
        List<K> result;
        for (const auto& pair : *this) {
            result.append(pair.first);
        }
        return result;
    }
    
    List<V> values() const {
        List<V> result;
        for (const auto& pair : *this) {
            result.append(pair.second);
        }
        return result;
    }
    
    int len() const { return this->size(); }
};

// ============================================================
// Python-like String Helpers
// ============================================================
inline String str(int value) { return String(value); }
inline String str(float value) { return String(value); }
inline String str(bool value) { return value ? "True" : "False"; }

inline int len(const String& s) { return s.length(); }

template<typename T>
inline int len(const std::vector<T>& v) { return v.size(); }

template<typename K, typename V>
inline int len(const std::map<K, V>& m) { return m.size(); }

// ============================================================
// Python-like Print
// ============================================================
template<typename T>
inline void print(const T& value) {
    Serial.println(value);
}

inline void print() {
    Serial.println();
}

// ============================================================
// Python-like Min/Max
// ============================================================
template<typename T>
inline T min(T a, T b) { return a < b ? a : b; }

template<typename T>
inline T max(T a, T b) { return a > b ? a : b; }

template<typename T>
inline T abs(T a) { return a < 0 ? -a : a; }

// ============================================================
// Tuple Support
// ============================================================
template<typename... Args>
using Tuple = std::tuple<Args...>;

} // namespace pyforge

// Import common items into global namespace for transpiled code
using pyforge::range;
using pyforge::List;
using pyforge::Dict;
using pyforge::print;
